# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
group5
group5 <- syn_pop(c(5,5,5,5))
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
group5
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
s.matrix-org.s.matrix
#s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
stateT(2, 3, c(.5,1), p)
p
p
stateT(2, 3, c(.5,1), p)
p
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
p
p <- syn_pop(c(2,3,1))
p
p
p
p2 <- syn_pop(c(2,3,1))
p - p2
p
p2
stateT(2, 3, c(.5,1), p)
p - p2
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
class(s.matrix)
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
class(org.s.matrix)
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
s.matrix-org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
p
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
another.s.matrix <- org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
another.s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
another.s.matrix-org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
another.s.matrix <- org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
another.s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
# another.s.matrix-org.s.matrix
s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
another.s.matrix <- org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
another.s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
# another.s.matrix-org.s.matrix
s.matrix-org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
another.s.matrix <- org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
another.s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
# another.s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
group5
View(group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
another.s.matrix <- org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
another.s.matrix <- stateT(origin, new.states, cum_probs, another.s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
# another.s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
group5
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
another.s.matrix <- org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
another.s.matrix <- stateT(origin, new.states, cum_probs, another.s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
another.s.matrix-org.s.matrix
# org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
another.s.matrix <- org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
another.s.matrix <- stateT(origin, new.states, cum_probs, another.s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#another.s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
another.s.matrix <- org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
another.s.matrix <- stateT(origin, new.states, cum_probs, another.s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#another.s.matrix-org.s.matrix
s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
