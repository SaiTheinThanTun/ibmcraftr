#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
org.s.matrix
group5
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix = s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix = s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix = s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix = s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix = s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix = s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
state_trans <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
origin_v <- s.matrix[,origin] #initializing a new vector for calculation
lo <- length(origin_v) #length of origin
org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
last_prob <- cum_probs[1]
for(i in new.states){
probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
rand <- runif(lo)
s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
last_prob <- probs_for
}
s.matrix-org.s.matrix
}
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
state_trans(1,2,.3,group5)
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
p
stateT(2, 3, c(.5,1), p)
p
stateT(2, 3, c(.5,1), p)
p
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
p
stateT(2, 3, c(.5,1), p)
p
p
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
p
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
p
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/Rcpp-tryouts/infectedornot.cpp')
state
Rcpp::sourceCpp('D:/OneDrive/Rcpp/Rcpp-tryouts/infectedornot.cpp')
state2
state
Rcpp::sourceCpp('D:/OneDrive/Rcpp/Rcpp-tryouts/infectedornot.cpp')
som
som
state
Rcpp::sourceCpp('D:/OneDrive/Rcpp/Rcpp-tryouts/infectedornot.cpp')
som
state
infectedornot(inf, rec, pat, state, ran1, ran2)
som
infectedornot(inf, rec, pat, state, ran1, ran2)
som
Rcpp::sourceCpp('D:/OneDrive/Rcpp/Rcpp-tryouts/infectedornot.cpp')
Rcpp::sourceCpp('R/stRCPP.cpp')
Rcpp::sourceCpp('R/stRCPP.cpp')
Rcpp::sourceCpp('R/stRCPP.cpp')
p
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
group5
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
s.matrix-org.s.matrix
#org.s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP <- function(origin, new.states, params, s.matrix){
#origin   #single number
#new.states  #a vector of length n (to index the matrix)
#params #a vector of length m (to calculate the probabilities)
#s.matrix  #state.matrix #a matrix cut from the data frame
#dimension check
if(ncol(s.matrix) <  max(c(origin, new.states))) stop("no such states in the input matrix") #stop if the dim requested is higher than input matrix
#origin_v <- s.matrix[,origin] #initializing a new vector for calculation
#lo <- length(origin_v) #length of origin
#org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?
#cummulative probability
probs <- 1-exp(-params*1) # calc probs from rates
compliments <- 1-probs
sum_compliments <- sum(compliments)
maxprobs <- sum(probs,compliments)
cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)
#load and run the Rcpp codes here
new.s.matrix <- stateT(origin, new.states, cum_probs, s.matrix)
#last_prob <- cum_probs[1]
# for(i in new.states){
#   probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition
#   rand <- runif(lo)
#
#   s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??
#   s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))
#   #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!
#   last_prob <- probs_for
# }
#s.matrix-org.s.matrix
#s.matrix-org.s.matrix
#org.s.matrix
new.s.matrix-s.matrix
}
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
stRCPP(1,2,.3,group5)
group5
group5
Rcpp::sourceCpp('R/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
library(ibmcraftr)
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
Rcpp::sourceCpp('R/stRCPP.cpp')
Rcpp::sourceCpp('D:/OneDrive/Rcpp/stRCPP.cpp')
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
state_trans(1,2,.3,group5)
group5 <- syn_pop(c(5,5,5,5))
stRCPP(1,2,.3,group5)
state_trans(1,2,.3,group5)
megapop <- syn_pop(c(3000,4000,2000,5000))
stRCPP(1,2,.3,megapop)
state_trans(1,2,.3,megapop)
library(profvis)
profvis(stRCPP(1,2,.3,megapop))
profvis(state_trans(1,2,.3,megapop))
system.time(stRCPP(1,2,.3,megapop))
system.time(state_trans(1,2,.3,megapop))
megapop <- syn_pop(c(300000000,4000,2000,5000))
megapop <- syn_pop(c(300000,4000,2000,5000))
megapop <- syn_pop(c(3000000,4000,2000,5000))
profvis(stRCPP(1,2,.3,megapop))
profvis(state_trans(1,2,.3,megapop))
system.time(stRCPP(1,2,.3,megapop))
system.time(state_trans(1,2,.3,megapop))
profvis(stRCPP(1,2,.3,megapop))
#profiling
library(Rcpp)
library(ibmcraftr)
sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
library(profvis)
megapop <- syn_pop(c(3000000,4000,2000,5000))
profvis(stRCPP(1,2,.3,megapop))
source("D:/OneDrive/Rcpp/stateTransitionTester.R")
library(Rcpp)
library(ibmcraftr)
#sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
source("D:/OneDrive/Rcpp/stateTransitionTester.R")
library(profvis)
megapop <- syn_pop(c(3000000,4000,2000,5000))
library(Rcpp)
library(ibmcraftr)
#sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
source("D:/OneDrive/Rcpp/stateTransitionTester.R")
library(profvis)
megapop <- syn_pop(c(3000000,4000,2000,5000))
profvis(stRCPP(1,2,.3,megapop))
profvis(state_trans(1,2,.3,megapop))
profvis(state_trans(1,2,.3,megapop))
profvis(state_trans(1,2,.3,megapop))
library(Rcpp)
library(ibmcraftr)
#sourceCpp("D:/OneDrive/Rcpp/stRCPP.cpp")
source("D:/OneDrive/Rcpp/stateTransitionTester.R")
library(profvis)
megapop <- syn_pop(c(3000000,4000,2000,5000))
profvis(state_trans(1,2,.3,megapop))
profvis(stRCPP(1,2,.3,megapop))
profvis(stRCPP(1,2,.3,megapop))
profvis(stRCPP(1,2,.3,megapop))
profvis(state_trans(1,2,.3,megapop))
system.time(stRCPP(1,2,.3,megapop))
system.time(state_trans(1,2,.3,megapop))
system.time(stRCPP(1,2,.3,megapop))
system.time(state_trans(1,2,.3,megapop))
system.time(stRCPP(1,2,.3,megapop))
system.time(state_trans(1,2,.3,megapop))
3E6
3000000
megapop <- syn_pop(c(3E6,4000,2000,5000)) #more than 3 million cases
profvis(stRCPP(1,2,.3,megapop))
source("D:/OneDrive/Rcpp/stateTransitionTester.R")
megapop <- syn_pop(c(3E6,4000,2000,5000)) #more than 3 million cases
profvis(stRCPP(1,2,.3,megapop))
profvis(state_trans(1,2,.3,megapop))
