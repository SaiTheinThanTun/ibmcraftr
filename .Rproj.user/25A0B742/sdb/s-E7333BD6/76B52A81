{
    "contents" : "#' Make state transitions.\n#'\n#' Take in the matrix of the states of synthetic population (created by \\code{syn_pop} function)\n#' and calculate the transitions from one state to other state(s) using the transition rate(s).\n#'\n#' @param origin A number which represents the column index \\code{s.matrix} you want to do the transition from\n#' @param new.states A numeric vector or a number which represents the column index \\code{s.matrix} you want as the destination(s) for the transition\n#' @param params A numeric vector of similar length to \\code{new.states} which serves as the transition rate(s)\n#' @param s.matrix A state matrix created from \\code{syn_pop} function\n#' @return A transition matrix of the same dimension as \\code{s.matrix}. -1 indicates that the individual has left the corresponding state.\n#'     +1 indicates that the individual has become the corresponding state.\n#' @examples\n#' pop <- syn_pop(c(19,1,0,0))\n#' state_trans(1,2,.1,pop)\n#' state_trans(1,4,100,pop)\n#'\n#' @export\n\n#this function is used\n#even if there's no terminal state, such as in SIRS models,\n#transitions from R to S has to be made first\n\n\n#next problem\n#testing for transitions to multiple states from a single state\n#example\n# in SEIRS system, E may get to I or R (without being infectious)\n# T1: E -> I, E -> R\n# T2: I -> R\n# original I is c(0,0,0,0,0,0,1)\n# New I from T1:c(0,0,1,1,0,0,1) #last I is the original I\n# New I after T2: c(0,0,0,0,0,0,1)\n# I have to make\n# c(0,0,0,0,0,0,1)+ c(0,0,1,1,0,0,1) == c(0,0,1,1,0,0,1)\n# test if their sum is >= 1. it'll give a logical matrix. add 0 to the matrix and you'll get back a numeric matrix\n\n#New R from T1:c(0,0,1,1,0,0,1) #last R is the original R\n\nstate_trans <- function(origin, new.states, params, s.matrix){\n  #origin   #single number\n  #new.states  #a vector of length n (to index the matrix)\n  #params #a vector of length m (to calculate the probabilities)\n  #s.matrix  #state.matrix #a matrix cut from the data frame\n\n  #dimension check\n  if(ncol(s.matrix) <  max(c(origin, new.states))) stop(\"no such states in the input matrix\") #stop if the dim requested is higher than input matrix\n\n  origin_v <- s.matrix[,origin] #initializing a new vector for calculation\n  lo <- length(origin_v) #length of origin\n  org.s.matrix <- s.matrix    #keeping the original matrix ??? for what?\n\n  #cummulative probability\n  probs <- 1-exp(-params*1) # calc probs from rates\n  compliments <- 1-probs\n  sum_compliments <- sum(compliments)\n  maxprobs <- sum(probs,compliments)\n  cum_probs <- cumsum(c(sum_compliments,probs)/maxprobs)\n\n  last_prob <- cum_probs[1]\n\n  for(i in new.states){\n    probs_for <- cum_probs[which(new.states==i)+1] #calculating probs_for for transition\n    rand <- runif(lo)\n\n    s.matrix[,i] <- s.matrix[,i]+(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob)) #origin is used here since ??\n    s.matrix[,origin] <- s.matrix[,origin]-(s.matrix[,origin]*(rand<probs_for)*(rand>last_prob))\n    #s.matrix[,-c(new.states,origin)] <- 0 #might not do this afterall!\n    last_prob <- probs_for\n  }\n  s.matrix-org.s.matrix\n}\n",
    "created" : 1470812475705.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1588914747",
    "id" : "76B52A81",
    "lastKnownWriteTime" : 1470845314,
    "path" : "D:/Dropbox/IBM project_Sai/r package/ibmcraftr/R/state_trans.R",
    "project_path" : "R/state_trans.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}